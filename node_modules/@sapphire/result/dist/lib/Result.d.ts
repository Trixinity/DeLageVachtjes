import { type Awaitable } from './common/utils';
import { err as _err } from './Result/Err';
import { ok as _ok } from './Result/Ok';
export * from './Result/IResult';
export * from './Result/ResultError';
export { _ok as ok, _err as err };
/**
 * The union of the two variations of `Result`.
 * @typeparam T The result's type.
 * @typeparam E The error's type.
 */
export declare type Result<T, E> = Result.Ok<T> | Result.Err<E>;
export declare namespace Result {
    type Resolvable<T, E> = T | Result<T, E>;
    function is<T, E>(value: Result<T, E>): true;
    function is(value: any): value is Result<unknown, unknown>;
    /**
     * Creates a {@link Result} out of a callback.
     * @typeparam T The result's type.
     * @typeparam E The error's type.
     */
    function from<T, E = unknown>(op: Resolvable<T, E> | (() => Resolvable<T, E>)): Result<T, E>;
    /**
     * Creates a {@link Result} out of a promise or async callback.
     * @typeparam T The result's type.
     * @typeparam E The error's type.
     */
    function fromAsync<T, E = unknown>(op: Awaitable<Resolvable<T, E>> | (() => Awaitable<Resolvable<T, E>>)): Promise<Result<T, E>>;
    /**
     * Creates an {@link Ok} that is the combination of all collected {@link Ok} values as an array, or the first
     * {@link Err} encountered.
     * @param results An array of {@link Result}s.
     * @returns A new {@link Result}.
     */
    function all<T extends readonly Result<any, any>[]>(results: [...T]): Result<UnwrapOkArray<T>, UnwrapErrArray<T>[number]>;
    /**
     * Returns the first encountered {@link Ok}, or an {@link Err} that is the combination of all collected error values.
     * @param results An array of {@link Result}s.
     * @returns A new {@link Result}.
     */
    function any<T extends readonly Result<any, any>[]>(results: [...T]): Result<UnwrapOkArray<T>[number], UnwrapErrArray<T>>;
    const err: typeof _err;
    const ok: typeof _ok;
    type Err<E> = import('./Result/Err').Err<E>;
    type Ok<T> = import('./Result/Ok').Ok<T>;
    type UnwrapOk<T extends Result<any, any>> = T extends Ok<infer S> ? S : never;
    type UnwrapErr<T extends Result<any, any>> = T extends Err<infer S> ? S : never;
    type UnwrapOkArray<T extends readonly Result<any, any>[] | []> = {
        -readonly [P in keyof T]: UnwrapOk<T[P]>;
    };
    type UnwrapErrArray<T extends readonly Result<any, any>[] | []> = {
        -readonly [P in keyof T]: UnwrapErr<T[P]>;
    };
}
//# sourceMappingURL=Result.d.ts.map