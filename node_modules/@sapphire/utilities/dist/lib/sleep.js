'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/lib/sleep.ts
var AbortError = class extends Error {
  constructor(message, options) {
    super(message, options);
    __publicField(this, "code");
    this.name = "AbortError";
    this.code = "ERR_ABORT";
  }
};
__name(AbortError, "AbortError");
function sleep(ms, value, options) {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => resolve(value), ms);
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      signal.addEventListener("abort", () => {
        clearTimeout(timer);
        reject(
          new AbortError("The operation was aborted", {
            cause: signal.reason
          })
        );
      });
    }
    if ((options == null ? void 0 : options.ref) === false && typeof timer === "object") {
      timer.unref();
    }
  });
}
__name(sleep, "sleep");
function sleepSync(ms, value) {
  return value;
}
__name(sleepSync, "sleepSync");

exports.AbortError = AbortError;
exports.sleep = sleep;
exports.sleepSync = sleepSync;
//# sourceMappingURL=sleep.js.map