export interface SleepOptions {
    /**
     * When provided the corresponding `AbortController` can be used to cancel an asynchronous action.
     */
    signal?: AbortSignal | undefined;
    /**
     * Set to `false` to indicate that the scheduled `Timeout`
     * should not require the Node.js event loop to remain active.
     * @default true
     */
    ref?: boolean | undefined;
}
export declare class AbortError extends Error {
    readonly code: string;
    constructor(message?: string, options?: {
        cause?: unknown;
    });
}
/**
 * Sleeps for the specified number of milliseconds.
 * @param ms The number of milliseconds to sleep.
 * @param value A value with which the promise is fulfilled.
 * @see {@link sleepSync} for a synchronous version.
 */
export declare function sleep<T = undefined>(ms: number, value?: T, options?: SleepOptions): Promise<T>;
/**
 * Sleeps for the specified number of milliseconds synchronously.
 * We should probably note that unlike {@link sleep} (which uses CPU tick times),
 * sleepSync uses wall clock times, so the precision is near-absolute by comparison.
 * That, and that synchronous means that nothing else in the thread will run for the length of the timer.
 * @param ms The number of milliseconds to sleep.
 * @param value A value to return.
 * @see {@link sleep} for an asynchronous version.
 */
export declare function sleepSync<T = undefined>(ms: number, value?: T): T;
//# sourceMappingURL=sleep.d.ts.map