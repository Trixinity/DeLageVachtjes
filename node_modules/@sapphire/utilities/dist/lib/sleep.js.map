{"version":3,"sources":["../../src/lib/sleep.ts"],"names":[],"mappings":";;;;;;;;;AAcO,IAAM,aAAN,cAAyB,MAAM;AAAA,EAE9B,YACN,SACA,SAGC;AACD,UAAM,SAAS,OAAO;AAPvB,wBAAgB;AAQf,SAAK,OAAO;AACZ,SAAK,OAAO;AAAA,EACb;AACD;AAZa;AAoBN,SAAS,MAAqB,IAAY,OAAW,SAAoC;AAC/F,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACvC,UAAM,QAAiC,WAAW,MAAM,QAAQ,KAAM,GAAG,EAAE;AAC3E,UAAM,SAAS,mCAAS;AACxB,QAAI,QAAQ;AACX,aAAO,iBAAiB,SAAS,MAAM;AACtC,qBAAa,KAAK;AAClB;AAAA,UACC,IAAI,WAAW,6BAA6B;AAAA,YAC3C,OAAO,OAAO;AAAA,UACf,CAAC;AAAA,QACF;AAAA,MACD,CAAC;AAAA,IACF;AACA,SAAI,mCAAS,SAAQ,SAAS,OAAO,UAAU,UAAU;AACxD,YAAM,MAAM;AAAA,IACb;AAAA,EACD,CAAC;AACF;AAlBgB;AA6BT,SAAS,UAAyB,IAAY,OAAc;AAClE,QAAM,MAAM,KAAK,IAAI,IAAI;AACzB,SAAO,KAAK,IAAI,IAAI;AAAK;AACzB,SAAO;AACR;AAJgB","sourcesContent":["export interface SleepOptions {\n\t/**\n\t * When provided the corresponding `AbortController` can be used to cancel an asynchronous action.\n\t */\n\tsignal?: AbortSignal | undefined;\n\n\t/**\n\t * Set to `false` to indicate that the scheduled `Timeout`\n\t * should not require the Node.js event loop to remain active.\n\t * @default true\n\t */\n\tref?: boolean | undefined;\n}\n\nexport class AbortError extends Error {\n\tpublic readonly code: string;\n\tpublic constructor(\n\t\tmessage?: string,\n\t\toptions?: {\n\t\t\tcause?: unknown;\n\t\t}\n\t) {\n\t\tsuper(message, options);\n\t\tthis.name = 'AbortError';\n\t\tthis.code = 'ERR_ABORT';\n\t}\n}\n\n/**\n * Sleeps for the specified number of milliseconds.\n * @param ms The number of milliseconds to sleep.\n * @param value A value with which the promise is fulfilled.\n * @see {@link sleepSync} for a synchronous version.\n */\nexport function sleep<T = undefined>(ms: number, value?: T, options?: SleepOptions): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst timer: NodeJS.Timeout | number = setTimeout(() => resolve(value!), ms);\n\t\tconst signal = options?.signal;\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', () => {\n\t\t\t\tclearTimeout(timer);\n\t\t\t\treject(\n\t\t\t\t\tnew AbortError('The operation was aborted', {\n\t\t\t\t\t\tcause: signal.reason\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t});\n\t\t}\n\t\tif (options?.ref === false && typeof timer === 'object') {\n\t\t\ttimer.unref();\n\t\t}\n\t});\n}\n\n/**\n * Sleeps for the specified number of milliseconds synchronously.\n * We should probably note that unlike {@link sleep} (which uses CPU tick times),\n * sleepSync uses wall clock times, so the precision is near-absolute by comparison.\n * That, and that synchronous means that nothing else in the thread will run for the length of the timer.\n * @param ms The number of milliseconds to sleep.\n * @param value A value to return.\n * @see {@link sleep} for an asynchronous version.\n */\nexport function sleepSync<T = undefined>(ms: number, value?: T): T {\n\tconst end = Date.now() + ms;\n\twhile (Date.now() < end) continue;\n\treturn value!;\n}\n"]}