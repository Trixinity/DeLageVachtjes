'use strict';

var discord_js = require('discord.js');
var PreconditionConditionAnd_js = require('./conditions/PreconditionConditionAnd.js');
var PreconditionConditionOr_js = require('./conditions/PreconditionConditionOr.js');
var PreconditionContainerSingle_js = require('./PreconditionContainerSingle.js');

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var PreconditionRunMode = /* @__PURE__ */ ((PreconditionRunMode2) => {
  PreconditionRunMode2[PreconditionRunMode2["Sequential"] = 0] = "Sequential";
  PreconditionRunMode2[PreconditionRunMode2["Parallel"] = 1] = "Parallel";
  return PreconditionRunMode2;
})(PreconditionRunMode || {});
var PreconditionRunCondition = /* @__PURE__ */ ((PreconditionRunCondition2) => {
  PreconditionRunCondition2[PreconditionRunCondition2["And"] = 0] = "And";
  PreconditionRunCondition2[PreconditionRunCondition2["Or"] = 1] = "Or";
  return PreconditionRunCondition2;
})(PreconditionRunCondition || {});
function isSingle(entry) {
  return typeof entry === "string" || Reflect.has(entry, "name");
}
__name(isSingle, "isSingle");
var _PreconditionContainerArray = class {
  constructor(data = [], parent = null) {
    this.entries = [];
    this.runCondition = parent?.runCondition === 0 /* And */ ? 1 /* Or */ : 0 /* And */;
    if (Array.isArray(data)) {
      const casted = data;
      this.mode = parent?.mode ?? 0 /* Sequential */;
      this.parse(casted);
    } else {
      const casted = data;
      this.mode = casted.mode;
      this.parse(casted.entries);
    }
  }
  add(entry) {
    this.entries.push(entry);
    return this;
  }
  append(entry) {
    this.entries.push(entry instanceof _PreconditionContainerArray ? entry : new PreconditionContainerSingle_js.PreconditionContainerSingle(entry));
    return this;
  }
  messageRun(message, command, context = {}) {
    return this.mode === 0 /* Sequential */ ? this.condition.messageSequential(message, command, this.entries, context) : this.condition.messageParallel(message, command, this.entries, context);
  }
  chatInputRun(interaction, command, context = {}) {
    return this.mode === 0 /* Sequential */ ? this.condition.chatInputSequential(interaction, command, this.entries, context) : this.condition.chatInputParallel(interaction, command, this.entries, context);
  }
  contextMenuRun(interaction, command, context = {}) {
    return this.mode === 0 /* Sequential */ ? this.condition.contextMenuSequential(interaction, command, this.entries, context) : this.condition.contextMenuParallel(interaction, command, this.entries, context);
  }
  parse(entries) {
    for (const entry of entries) {
      this.add(
        isSingle(entry) ? new PreconditionContainerSingle_js.PreconditionContainerSingle(entry) : new _PreconditionContainerArray(entry, this)
      );
    }
    return this;
  }
  get condition() {
    return _PreconditionContainerArray.conditions.get(this.runCondition);
  }
};
var PreconditionContainerArray = _PreconditionContainerArray;
__name(PreconditionContainerArray, "PreconditionContainerArray");
PreconditionContainerArray.conditions = new discord_js.Collection([
  [0 /* And */, PreconditionConditionAnd_js.PreconditionConditionAnd],
  [1 /* Or */, PreconditionConditionOr_js.PreconditionConditionOr]
]);

exports.PreconditionContainerArray = PreconditionContainerArray;
exports.PreconditionRunCondition = PreconditionRunCondition;
exports.PreconditionRunMode = PreconditionRunMode;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=PreconditionContainerArray.js.map