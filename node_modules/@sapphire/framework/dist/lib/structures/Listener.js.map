{"version":3,"sources":["../../../src/lib/structures/Listener.ts"],"names":[],"mappings":";;;;AAAA,SAAS,aAAa;AACtB,SAAS,cAAc;AAGvB,SAAS,cAAc;AAyChB,IAAe,WAAf,cAA2H,MAAS;AAAA,EAqBnI,YAAY,SAA2B,UAAa,CAAC,GAAQ;AACnE,UAAM,SAAS,OAAO;AAEtB,SAAK,UACJ,OAAO,QAAQ,YAAY,cACxB,KAAK,UAAU,UACd,OAAO,QAAQ,YAAY,WAAY,QAAQ,IAAI,KAAK,UAAU,QAAQ,QAAQ,OAAO,IAAqB,QAAQ,YACvH;AACJ,SAAK,QAAQ,QAAQ,SAAS,KAAK;AACnC,SAAK,OAAO,QAAQ,QAAQ;AAE5B,SAAK,YAAY,KAAK,WAAW,KAAK,QAAS,KAAK,OAAO,KAAK,SAAS,KAAK,IAAI,IAAI,KAAK,KAAK,KAAK,IAAI,IAAK;AAG9G,QAAI,KAAK,YAAY,QAAQ,KAAK,cAAc;AAAM,WAAK,UAAU;AAAA,EACtE;AAAA,EAIgB,SAAS;AACxB,QAAI,KAAK,WAAW;AACnB,YAAM,UAAU,KAAK;AAGrB,YAAM,eAAe,QAAQ,gBAAgB;AAC7C,UAAI,iBAAiB;AAAG,gBAAQ,gBAAgB,eAAe,CAAC;AAEhE,cAAQ,KAAK,OAAO,SAAS,MAAM,KAAK,OAAO,KAAK,SAAS;AAAA,IAC9D;AACA,WAAO,MAAM,OAAO;AAAA,EACrB;AAAA,EAEgB,WAAW;AAC1B,QAAI,CAAC,KAAK,QAAQ,KAAK,WAAW;AACjC,YAAM,UAAU,KAAK;AAGrB,YAAM,eAAe,QAAQ,gBAAgB;AAC7C,UAAI,iBAAiB;AAAG,gBAAQ,gBAAgB,eAAe,CAAC;AAEhE,cAAQ,IAAI,KAAK,OAAO,KAAK,SAAS;AACtC,WAAK,YAAY;AAAA,IAClB;AAEA,WAAO,MAAM,SAAS;AAAA,EACvB;AAAA,EAEgB,SAAuB;AACtC,WAAO;AAAA,MACN,GAAG,MAAM,OAAO;AAAA,MAChB,MAAM,KAAK;AAAA,MACX,OAAO,KAAK;AAAA,IACb;AAAA,EACD;AAAA,EAEA,MAAc,QAAQ,MAAiB;AAEtC,UAAM,SAAS,MAAM,OAAO,UAAU,MAAM,KAAK,IAAI,GAAG,IAAI,CAAC;AAC7D,WAAO,WAAW,CAAC,UAAU,KAAK,UAAU,OAAO,KAAK,OAAO,eAAe,OAAO,EAAE,OAAO,KAAK,CAAC,CAAC;AAAA,EACtG;AAAA,EAEA,MAAc,YAAY,MAAiB;AAC1C,UAAM,KAAK,KAAK,GAAG,IAAI;AACvB,UAAM,KAAK,OAAO;AAAA,EACnB;AACD;AAtFsB","sourcesContent":["import { Piece } from '@sapphire/pieces';\nimport { Result } from '@sapphire/result';\nimport type { Client, ClientEvents } from 'discord.js';\nimport type { EventEmitter } from 'node:events';\nimport { Events } from '../types/Events';\n\n/**\n * The base event class. This class is abstract and is to be extended by subclasses, which should implement the methods. In\n * Sapphire's workflow, listeners are called when the emitter they listen on emits a new message with the same event name.\n *\n * @example\n * ```typescript\n * // TypeScript:\n * import { Events, Listener } from '@sapphire/framework';\n *\n * // Define a class extending `Listener`, then export it.\n * // NOTE: You can use `export default` or `export =` too.\n * export class CoreListener extends Listener<typeof Events.ClientReady> {\n *   public constructor(context: Listener.Context) {\n *     super(context, { event: Events.ClientReady, once: true });\n *   }\n *\n *   public run() {\n *     this.container.client.id ??= this.container.client.user?.id ?? null;\n *   }\n * }\n * ```\n *\n * @example\n * ```javascript\n * // JavaScript:\n * const { Events, Listener } = require('@sapphire/framework');\n *\n * // Define a class extending `Listener`, then export it.\n * module.exports = class CoreListener extends Listener {\n *   constructor(context) {\n *     super(context, { event: Events.ClientReady, once: true });\n *   }\n *\n *   run() {\n *     this.container.client.id ??= this.container.client.user?.id ?? null;\n *   }\n * }\n * ```\n */\nexport abstract class Listener<E extends keyof ClientEvents | symbol = '', O extends Listener.Options = Listener.Options> extends Piece<O> {\n\t/**\n\t * The emitter, if any.\n\t * @since 2.0.0\n\t */\n\tpublic readonly emitter: EventEmitter | null;\n\n\t/**\n\t * The name of the event the listener listens to.\n\t * @since 2.0.0\n\t */\n\tpublic readonly event: string | symbol;\n\n\t/**\n\t * Whether or not the listener will be unloaded after the first run.\n\t * @since 2.0.0\n\t */\n\tpublic readonly once: boolean;\n\n\tprivate _listener: ((...args: any[]) => void) | null;\n\n\tpublic constructor(context: Listener.Context, options: O = {} as O) {\n\t\tsuper(context, options);\n\n\t\tthis.emitter =\n\t\t\ttypeof options.emitter === 'undefined'\n\t\t\t\t? this.container.client\n\t\t\t\t: (typeof options.emitter === 'string' ? (Reflect.get(this.container.client, options.emitter) as EventEmitter) : options.emitter) ??\n\t\t\t\t  null;\n\t\tthis.event = options.event ?? this.name;\n\t\tthis.once = options.once ?? false;\n\n\t\tthis._listener = this.emitter && this.event ? (this.once ? this._runOnce.bind(this) : this._run.bind(this)) : null;\n\n\t\t// If there's no emitter or no listener, disable:\n\t\tif (this.emitter === null || this._listener === null) this.enabled = false;\n\t}\n\n\tpublic abstract run(...args: E extends keyof ClientEvents ? ClientEvents[E] : unknown[]): unknown;\n\n\tpublic override onLoad() {\n\t\tif (this._listener) {\n\t\t\tconst emitter = this.emitter!;\n\n\t\t\t// Increment the maximum amount of listeners by one:\n\t\t\tconst maxListeners = emitter.getMaxListeners();\n\t\t\tif (maxListeners !== 0) emitter.setMaxListeners(maxListeners + 1);\n\n\t\t\temitter[this.once ? 'once' : 'on'](this.event, this._listener);\n\t\t}\n\t\treturn super.onLoad();\n\t}\n\n\tpublic override onUnload() {\n\t\tif (!this.once && this._listener) {\n\t\t\tconst emitter = this.emitter!;\n\n\t\t\t// Increment the maximum amount of listeners by one:\n\t\t\tconst maxListeners = emitter.getMaxListeners();\n\t\t\tif (maxListeners !== 0) emitter.setMaxListeners(maxListeners - 1);\n\n\t\t\temitter.off(this.event, this._listener);\n\t\t\tthis._listener = null;\n\t\t}\n\n\t\treturn super.onUnload();\n\t}\n\n\tpublic override toJSON(): ListenerJSON {\n\t\treturn {\n\t\t\t...super.toJSON(),\n\t\t\tonce: this.once,\n\t\t\tevent: this.event\n\t\t};\n\t}\n\n\tprivate async _run(...args: unknown[]) {\n\t\t// @ts-expect-error This seems to be a TS bug, so for now ts-expect-error it\n\t\tconst result = await Result.fromAsync(() => this.run(...args));\n\t\tresult.inspectErr((error) => this.container.client.emit(Events.ListenerError, error, { piece: this }));\n\t}\n\n\tprivate async _runOnce(...args: unknown[]) {\n\t\tawait this._run(...args);\n\t\tawait this.unload();\n\t}\n}\n\nexport interface ListenerOptions extends Piece.Options {\n\treadonly emitter?: keyof Client | EventEmitter;\n\treadonly event?: string | symbol;\n\treadonly once?: boolean;\n}\n\nexport interface ListenerJSON extends Piece.JSON {\n\tevent: string | symbol;\n\tonce: boolean;\n}\n\nexport namespace Listener {\n\texport type Options = ListenerOptions;\n\texport type JSON = ListenerJSON;\n\texport type Context = Piece.Context;\n}\n"]}