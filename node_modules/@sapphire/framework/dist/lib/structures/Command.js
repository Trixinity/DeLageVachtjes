'use strict';

var lexure = require('@sapphire/lexure');
var pieces = require('@sapphire/pieces');
var utilities = require('@sapphire/utilities');
var discord_js = require('discord.js');
var Args_js = require('../parsers/Args.js');
var Enums_js = require('../types/Enums.js');
var ApplicationCommandRegistries_js = require('../utils/application-commands/ApplicationCommandRegistries.js');
var emitRegistryError_js = require('../utils/application-commands/emitRegistryError.js');
var getNeededParameters_js = require('../utils/application-commands/getNeededParameters.js');
var PreconditionContainerArray_js = require('../utils/preconditions/PreconditionContainerArray.js');
var FlagUnorderedStrategy_js = require('../utils/strategies/FlagUnorderedStrategy.js');

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var Command = class extends pieces.AliasPiece {
  constructor(context, options = {}) {
    super(context, { ...options, name: (options.name ?? context.name).toLowerCase() });
    this.applicationCommandRegistry = ApplicationCommandRegistries_js.acquire(this.name);
    this.description = options.description ?? "";
    this.detailedDescription = options.detailedDescription ?? "";
    this.strategy = new FlagUnorderedStrategy_js.FlagUnorderedStrategy(options);
    this.fullCategory = options.fullCategory ?? this.location.directories;
    this.typing = options.typing ?? true;
    this.lexer = new lexure.Lexer({
      quotes: options.quotes ?? [
        ['"', '"'],
        ["\u201C", "\u201D"],
        ["\u300C", "\u300D"],
        ["\xAB", "\xBB"]
      ]
    });
    if (options.generateDashLessAliases) {
      const dashLessAliases = [];
      if (this.name.includes("-"))
        dashLessAliases.push(this.name.replace(/-/g, ""));
      for (const alias of this.aliases)
        if (alias.includes("-"))
          dashLessAliases.push(alias.replace(/-/g, ""));
      this.aliases = [...this.aliases, ...dashLessAliases];
    }
    if (options.generateUnderscoreLessAliases) {
      const underscoreLessAliases = [];
      if (this.name.includes("_"))
        underscoreLessAliases.push(this.name.replace(/_/g, ""));
      for (const alias of this.aliases)
        if (alias.includes("_"))
          underscoreLessAliases.push(alias.replace(/_/g, ""));
      this.aliases = [...this.aliases, ...underscoreLessAliases];
    }
    this.preconditions = new PreconditionContainerArray_js.PreconditionContainerArray(options.preconditions);
    this.parseConstructorPreConditions(options);
  }
  messagePreParse(message, parameters, context) {
    const parser = new lexure.Parser(this.strategy);
    const args = new lexure.ArgumentStream(parser.run(this.lexer.run(parameters)));
    return new Args_js.Args(message, this, args, context);
  }
  get category() {
    return this.fullCategory.length > 0 ? this.fullCategory[0] : null;
  }
  get subCategory() {
    return this.fullCategory.length > 1 ? this.fullCategory[1] : null;
  }
  get parentCategory() {
    return this.fullCategory.length > 1 ? this.fullCategory[this.fullCategory.length - 1] : null;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      description: this.description,
      detailedDescription: this.detailedDescription,
      category: this.category
    };
  }
  supportsMessageCommands() {
    return Reflect.has(this, "messageRun");
  }
  supportsChatInputCommands() {
    return Reflect.has(this, "chatInputRun");
  }
  supportsContextMenuCommands() {
    return Reflect.has(this, "contextMenuRun");
  }
  supportsAutocompleteInteractions() {
    return Reflect.has(this, "autocompleteRun");
  }
  async reload() {
    const store = this.store;
    const registry = this.applicationCommandRegistry;
    for (const nameOrId of registry.chatInputCommands) {
      const aliasedPiece = store.aliases.get(nameOrId);
      if (aliasedPiece === this) {
        store.aliases.delete(nameOrId);
      }
    }
    for (const nameOrId of registry.contextMenuCommands) {
      const aliasedPiece = store.aliases.get(nameOrId);
      if (aliasedPiece === this) {
        store.aliases.delete(nameOrId);
      }
    }
    registry.chatInputCommands.clear();
    registry.contextMenuCommands.clear();
    registry.guildIdsToFetch.clear();
    registry["apiCalls"].length = 0;
    await super.reload();
    const updatedPiece = store.get(this.name);
    if (!updatedPiece)
      return;
    const updatedRegistry = updatedPiece.applicationCommandRegistry;
    if (updatedPiece.registerApplicationCommands) {
      try {
        await updatedPiece.registerApplicationCommands(updatedRegistry);
      } catch (err) {
        emitRegistryError_js.emitRegistryError(err, updatedPiece);
        return;
      }
    }
    const { applicationCommands, globalCommands, guildCommands } = await getNeededParameters_js.getNeededRegistryParameters(updatedRegistry.guildIdsToFetch);
    await updatedRegistry["runAPICalls"](applicationCommands, globalCommands, guildCommands);
    for (const nameOrId of updatedRegistry.chatInputCommands) {
      store.aliases.set(nameOrId, updatedPiece);
    }
    for (const nameOrId of updatedRegistry.contextMenuCommands) {
      store.aliases.set(nameOrId, updatedPiece);
    }
  }
  parseConstructorPreConditions(options) {
    this.parseConstructorPreConditionsRunIn(options);
    this.parseConstructorPreConditionsNsfw(options);
    this.parseConstructorPreConditionsRequiredClientPermissions(options);
    this.parseConstructorPreConditionsRequiredUserPermissions(options);
    this.parseConstructorPreConditionsCooldown(options);
  }
  parseConstructorPreConditionsNsfw(options) {
    if (options.nsfw)
      this.preconditions.append(CommandPreConditions.NotSafeForWork);
  }
  parseConstructorPreConditionsRunIn(options) {
    const runIn = this.resolveConstructorPreConditionsRunType(options.runIn);
    if (runIn !== null)
      this.preconditions.append(runIn);
  }
  parseConstructorPreConditionsRequiredClientPermissions(options) {
    const permissions = new discord_js.Permissions(options.requiredClientPermissions);
    if (permissions.bitfield !== 0n) {
      this.preconditions.append({ name: CommandPreConditions.ClientPermissions, context: { permissions } });
    }
  }
  parseConstructorPreConditionsRequiredUserPermissions(options) {
    const permissions = new discord_js.Permissions(options.requiredUserPermissions);
    if (permissions.bitfield !== 0n) {
      this.preconditions.append({ name: CommandPreConditions.UserPermissions, context: { permissions } });
    }
  }
  parseConstructorPreConditionsCooldown(options) {
    const { defaultCooldown } = this.container.client.options;
    const filtered = defaultCooldown?.filteredCommands?.includes(this.name) ?? false;
    const limit = options.cooldownLimit ?? (filtered ? 0 : defaultCooldown?.limit ?? 1);
    const delay = options.cooldownDelay ?? (filtered ? 0 : defaultCooldown?.delay ?? 0);
    if (limit && delay) {
      const scope = options.cooldownScope ?? defaultCooldown?.scope ?? Enums_js.BucketScope.User;
      const filteredUsers = options.cooldownFilteredUsers ?? defaultCooldown?.filteredUsers;
      this.preconditions.append({
        name: CommandPreConditions.Cooldown,
        context: { scope, limit, delay, filteredUsers }
      });
    }
  }
  resolveConstructorPreConditionsRunType(runIn) {
    if (utilities.isNullish(runIn))
      return null;
    if (typeof runIn === "string") {
      switch (runIn) {
        case "DM":
          return CommandPreConditions.DirectMessageOnly;
        case "GUILD_TEXT":
          return CommandPreConditions.GuildTextOnly;
        case "GUILD_VOICE":
          return CommandPreConditions.GuildVoiceOnly;
        case "GUILD_NEWS":
          return CommandPreConditions.GuildNewsOnly;
        case "GUILD_NEWS_THREAD":
          return CommandPreConditions.GuildNewsThreadOnly;
        case "GUILD_PUBLIC_THREAD":
          return CommandPreConditions.GuildPublicThreadOnly;
        case "GUILD_PRIVATE_THREAD":
          return CommandPreConditions.GuildPrivateThreadOnly;
        case "GUILD_ANY":
          return CommandPreConditions.GuildOnly;
        default:
          return null;
      }
    }
    if (runIn.length === 0) {
      throw new Error(`${this.constructor.name}[${this.name}]: "runIn" was specified as an empty array.`);
    }
    if (runIn.length === 1) {
      return this.resolveConstructorPreConditionsRunType(runIn[0]);
    }
    const keys = new Set(runIn);
    const dm = keys.has("DM");
    const guildText = keys.has("GUILD_TEXT");
    const guildVoice = keys.has("GUILD_VOICE");
    const guildNews = keys.has("GUILD_NEWS");
    const guild = guildText && guildNews && guildVoice;
    if (dm && guild)
      return null;
    const guildPublicThread = keys.has("GUILD_PUBLIC_THREAD");
    const guildPrivateThread = keys.has("GUILD_PRIVATE_THREAD");
    const guildNewsThread = keys.has("GUILD_NEWS_THREAD");
    const guildThreads = guildPublicThread && guildPrivateThread && guildNewsThread;
    if (guildThreads && keys.size === 3) {
      return CommandPreConditions.GuildThreadOnly;
    }
    const preconditions = new PreconditionContainerArray_js.PreconditionContainerArray();
    if (dm)
      preconditions.append(CommandPreConditions.DirectMessageOnly);
    if (guild) {
      preconditions.append(CommandPreConditions.GuildOnly);
    } else {
      if (guildText) {
        preconditions.append(CommandPreConditions.GuildTextOnly);
      } else {
        if (guildPublicThread)
          preconditions.append(CommandPreConditions.GuildPublicThreadOnly);
        if (guildPrivateThread)
          preconditions.append(CommandPreConditions.GuildPrivateThreadOnly);
      }
      if (guildNews) {
        preconditions.append(CommandPreConditions.GuildNewsOnly);
      } else if (guildNewsThread) {
        preconditions.append(CommandPreConditions.GuildNewsThreadOnly);
      }
      if (guildVoice) {
        preconditions.append(CommandPreConditions.GuildVoiceOnly);
      }
    }
    return preconditions;
  }
};
__name(Command, "Command");
var CommandOptionsRunTypeEnum = /* @__PURE__ */ ((CommandOptionsRunTypeEnum2) => {
  CommandOptionsRunTypeEnum2["Dm"] = "DM";
  CommandOptionsRunTypeEnum2["GuildText"] = "GUILD_TEXT";
  CommandOptionsRunTypeEnum2["GuildVoice"] = "GUILD_VOICE";
  CommandOptionsRunTypeEnum2["GuildNews"] = "GUILD_NEWS";
  CommandOptionsRunTypeEnum2["GuildNewsThread"] = "GUILD_NEWS_THREAD";
  CommandOptionsRunTypeEnum2["GuildPublicThread"] = "GUILD_PUBLIC_THREAD";
  CommandOptionsRunTypeEnum2["GuildPrivateThread"] = "GUILD_PRIVATE_THREAD";
  CommandOptionsRunTypeEnum2["GuildAny"] = "GUILD_ANY";
  return CommandOptionsRunTypeEnum2;
})(CommandOptionsRunTypeEnum || {});
var CommandPreConditions = /* @__PURE__ */ ((CommandPreConditions2) => {
  CommandPreConditions2["Cooldown"] = "Cooldown";
  CommandPreConditions2["DirectMessageOnly"] = "DMOnly";
  CommandPreConditions2["GuildNewsOnly"] = "GuildNewsOnly";
  CommandPreConditions2["GuildNewsThreadOnly"] = "GuildNewsThreadOnly";
  CommandPreConditions2["GuildOnly"] = "GuildOnly";
  CommandPreConditions2["GuildPrivateThreadOnly"] = "GuildPrivateThreadOnly";
  CommandPreConditions2["GuildPublicThreadOnly"] = "GuildPublicThreadOnly";
  CommandPreConditions2["GuildTextOnly"] = "GuildTextOnly";
  CommandPreConditions2["GuildVoiceOnly"] = "GuildVoiceOnly";
  CommandPreConditions2["GuildThreadOnly"] = "GuildThreadOnly";
  CommandPreConditions2["NotSafeForWork"] = "NSFW";
  CommandPreConditions2["ClientPermissions"] = "ClientPermissions";
  CommandPreConditions2["UserPermissions"] = "UserPermissions";
  return CommandPreConditions2;
})(CommandPreConditions || {});

exports.Command = Command;
exports.CommandOptionsRunTypeEnum = CommandOptionsRunTypeEnum;
exports.CommandPreConditions = CommandPreConditions;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=Command.js.map