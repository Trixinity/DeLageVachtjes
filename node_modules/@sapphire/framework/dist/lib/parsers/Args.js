'use strict';

var lexure = require('@sapphire/lexure');
var pieces = require('@sapphire/pieces');
var result = require('@sapphire/result');
var ArgumentError_js = require('../errors/ArgumentError.js');
var Identifiers_js = require('../errors/Identifiers.js');
var UserError_js = require('../errors/UserError.js');

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var Args = class {
  constructor(message, command, parser, context) {
    this.states = [];
    this.message = message;
    this.command = command;
    this.parser = parser;
    this.commandContext = context;
  }
  start() {
    this.parser.reset();
    return this;
  }
  async pickResult(type, options = {}) {
    const argument = this.resolveArgument(type);
    if (!argument)
      return this.unavailableArgument(type);
    const result = await this.parser.singleParseAsync(
      async (arg) => argument.run(arg, {
        args: this,
        argument,
        message: this.message,
        command: this.command,
        commandContext: this.commandContext,
        ...options
      })
    );
    if (result.isErrAnd((value) => value === null)) {
      return this.missingArguments();
    }
    return result;
  }
  async pick(type, options) {
    const result = await this.pickResult(type, options);
    return result.unwrap();
  }
  async restResult(type, options = {}) {
    const argument = this.resolveArgument(type);
    if (!argument)
      return this.unavailableArgument(type);
    if (this.parser.finished)
      return this.missingArguments();
    const state = this.parser.save();
    const data = lexure.join(this.parser.many().unwrapOr([]));
    const result = await argument.run(data, {
      args: this,
      argument,
      message: this.message,
      command: this.command,
      commandContext: this.commandContext,
      ...options
    });
    return result.inspectErr(() => this.parser.restore(state));
  }
  async rest(type, options) {
    const result = await this.restResult(type, options);
    return result.unwrap();
  }
  async repeatResult(type, options = {}) {
    const argument = this.resolveArgument(type);
    if (!argument)
      return this.unavailableArgument(type);
    if (this.parser.finished)
      return this.missingArguments();
    const output = [];
    for (let i = 0, times = options.times ?? Infinity; i < times; i++) {
      const result = await this.parser.singleParseAsync(
        async (arg) => argument.run(arg, {
          args: this,
          argument,
          message: this.message,
          command: this.command,
          commandContext: this.commandContext,
          ...options
        })
      );
      if (result.isErr()) {
        const error = result.unwrapErr();
        if (error === null)
          break;
        if (output.length === 0) {
          return result;
        }
        break;
      }
      output.push(result.unwrap());
    }
    return result.Result.ok(output);
  }
  async repeat(type, options) {
    const result = await this.repeatResult(type, options);
    return result.unwrap();
  }
  async peekResult(type, options = {}) {
    this.save();
    const result = typeof type === "function" ? await type() : await this.pickResult(type, options);
    this.restore();
    return result;
  }
  async peek(type, options) {
    const result = await this.peekResult(type, options);
    return result.unwrap();
  }
  nextMaybe(cb) {
    return result.Option.from(typeof cb === "function" ? this.parser.singleMap(cb) : this.parser.single());
  }
  next(cb) {
    const value = cb ? this.nextMaybe(cb) : this.nextMaybe();
    return value.unwrapOr(null);
  }
  getFlags(...keys) {
    return this.parser.flag(...keys);
  }
  getOptionResult(...keys) {
    return this.parser.option(...keys);
  }
  getOption(...keys) {
    return this.parser.option(...keys).unwrapOr(null);
  }
  getOptionsResult(...keys) {
    return this.parser.options(...keys);
  }
  getOptions(...keys) {
    return this.parser.options(...keys).unwrapOr(null);
  }
  save() {
    this.states.push(this.parser.save());
  }
  restore() {
    if (this.states.length !== 0)
      this.parser.restore(this.states.pop());
  }
  get finished() {
    return this.parser.finished;
  }
  toJSON() {
    return { message: this.message, command: this.command, commandContext: this.commandContext };
  }
  unavailableArgument(type) {
    const name = typeof type === "string" ? type : type.name;
    return result.Result.err(
      new UserError_js.UserError({
        identifier: Identifiers_js.Identifiers.ArgsUnavailable,
        message: `The argument "${name}" was not found.`,
        context: { name, ...this.toJSON() }
      })
    );
  }
  missingArguments() {
    return result.Result.err(new UserError_js.UserError({ identifier: Identifiers_js.Identifiers.ArgsMissing, message: "There are no more arguments.", context: this.toJSON() }));
  }
  resolveArgument(arg) {
    if (typeof arg === "object")
      return arg;
    return pieces.container.stores.get("arguments").get(arg);
  }
  static make(cb, name = "") {
    return { run: cb, name };
  }
  static ok(value) {
    return result.Result.ok(value);
  }
  static error(options) {
    return result.Result.err(new ArgumentError_js.ArgumentError(options));
  }
};
__name(Args, "Args");

exports.Args = Args;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=Args.js.map