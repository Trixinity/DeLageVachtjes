'use strict';

var ratelimits = require('@sapphire/ratelimits');
var Identifiers_js = require('../lib/errors/Identifiers.js');
var Precondition_js = require('../lib/structures/Precondition.js');
var Enums_js = require('../lib/types/Enums.js');

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var CorePrecondition = class extends Precondition_js.AllFlowsPrecondition {
  constructor() {
    super(...arguments);
    this.buckets = /* @__PURE__ */ new WeakMap();
  }
  messageRun(message, command, context) {
    const cooldownId = this.getIdFromMessage(message, context);
    return this.sharedRun(message.author.id, command, context, cooldownId, "message");
  }
  chatInputRun(interaction, command, context) {
    const cooldownId = this.getIdFromInteraction(interaction, context);
    return this.sharedRun(interaction.user.id, command, context, cooldownId, "chat input");
  }
  contextMenuRun(interaction, command, context) {
    const cooldownId = this.getIdFromInteraction(interaction, context);
    return this.sharedRun(interaction.user.id, command, context, cooldownId, "context menu");
  }
  sharedRun(authorId, command, context, cooldownId, commandType) {
    if (context.external)
      return this.ok();
    if (!context.delay)
      return this.ok();
    if (context.filteredUsers?.includes(authorId))
      return this.ok();
    const ratelimit = this.getManager(command, context).acquire(cooldownId);
    if (ratelimit.limited) {
      const remaining = ratelimit.remainingTime;
      return this.error({
        identifier: Identifiers_js.Identifiers.PreconditionCooldown,
        message: `There is a cooldown in effect for this ${commandType} command. It'll be available at ${new Date(
          ratelimit.expires
        ).toISOString()}.`,
        context: { remaining }
      });
    }
    ratelimit.consume();
    return this.ok();
  }
  getIdFromMessage(message, context) {
    switch (context.scope) {
      case Enums_js.BucketScope.Global:
        return "global";
      case Enums_js.BucketScope.Channel:
        return message.channel.id;
      case Enums_js.BucketScope.Guild:
        return message.guild?.id ?? message.channel.id;
      default:
        return message.author.id;
    }
  }
  getIdFromInteraction(interaction, context) {
    switch (context.scope) {
      case Enums_js.BucketScope.Global:
        return "global";
      case Enums_js.BucketScope.Channel:
        return interaction.channelId;
      case Enums_js.BucketScope.Guild:
        return interaction.guildId ?? interaction.channelId;
      default:
        return interaction.user.id;
    }
  }
  getManager(command, context) {
    let manager = this.buckets.get(command);
    if (!manager) {
      manager = new ratelimits.RateLimitManager(context.delay, context.limit);
      this.buckets.set(command, manager);
    }
    return manager;
  }
};
__name(CorePrecondition, "CorePrecondition");

exports.CorePrecondition = CorePrecondition;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=Cooldown.js.map